
/* !!! This is code generated by Prisma. Do not edit directly. !!! */
/* eslint-disable */
// biome-ignore-all lint: generated file
// @ts-nocheck 
/*
 * This file exports the `EloHistory` model and its related types.
 *
 * ðŸŸ¢ You can import this file directly.
 */
import type * as runtime from "@prisma/client/runtime/client"
import type * as $Enums from "../enums"
import type * as Prisma from "../internal/prismaNamespace"

/**
 * Model EloHistory
 * *
 *  * ELO History - Track rating changes over time (future)
 */
export type EloHistoryModel = runtime.Types.Result.DefaultSelection<Prisma.$EloHistoryPayload>

export type AggregateEloHistory = {
  _count: EloHistoryCountAggregateOutputType | null
  _avg: EloHistoryAvgAggregateOutputType | null
  _sum: EloHistorySumAggregateOutputType | null
  _min: EloHistoryMinAggregateOutputType | null
  _max: EloHistoryMaxAggregateOutputType | null
}

export type EloHistoryAvgAggregateOutputType = {
  rating: number | null
  change: number | null
}

export type EloHistorySumAggregateOutputType = {
  rating: number | null
  change: number | null
}

export type EloHistoryMinAggregateOutputType = {
  id: string | null
  userId: string | null
  rating: number | null
  change: number | null
  gameId: string | null
  timestamp: Date | null
}

export type EloHistoryMaxAggregateOutputType = {
  id: string | null
  userId: string | null
  rating: number | null
  change: number | null
  gameId: string | null
  timestamp: Date | null
}

export type EloHistoryCountAggregateOutputType = {
  id: number
  userId: number
  rating: number
  change: number
  gameId: number
  timestamp: number
  _all: number
}


export type EloHistoryAvgAggregateInputType = {
  rating?: true
  change?: true
}

export type EloHistorySumAggregateInputType = {
  rating?: true
  change?: true
}

export type EloHistoryMinAggregateInputType = {
  id?: true
  userId?: true
  rating?: true
  change?: true
  gameId?: true
  timestamp?: true
}

export type EloHistoryMaxAggregateInputType = {
  id?: true
  userId?: true
  rating?: true
  change?: true
  gameId?: true
  timestamp?: true
}

export type EloHistoryCountAggregateInputType = {
  id?: true
  userId?: true
  rating?: true
  change?: true
  gameId?: true
  timestamp?: true
  _all?: true
}

export type EloHistoryAggregateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Filter which EloHistory to aggregate.
   */
  where?: Prisma.EloHistoryWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of EloHistories to fetch.
   */
  orderBy?: Prisma.EloHistoryOrderByWithRelationInput | Prisma.EloHistoryOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the start position
   */
  cursor?: Prisma.EloHistoryWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `Â±n` EloHistories from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` EloHistories.
   */
  skip?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Count returned EloHistories
  **/
  _count?: true | EloHistoryCountAggregateInputType
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Select which fields to average
  **/
  _avg?: EloHistoryAvgAggregateInputType
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Select which fields to sum
  **/
  _sum?: EloHistorySumAggregateInputType
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Select which fields to find the minimum value
  **/
  _min?: EloHistoryMinAggregateInputType
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Select which fields to find the maximum value
  **/
  _max?: EloHistoryMaxAggregateInputType
}

export type GetEloHistoryAggregateType<T extends EloHistoryAggregateArgs> = {
      [P in keyof T & keyof AggregateEloHistory]: P extends '_count' | 'count'
    ? T[P] extends true
      ? number
      : Prisma.GetScalarType<T[P], AggregateEloHistory[P]>
    : Prisma.GetScalarType<T[P], AggregateEloHistory[P]>
}




export type EloHistoryGroupByArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  where?: Prisma.EloHistoryWhereInput
  orderBy?: Prisma.EloHistoryOrderByWithAggregationInput | Prisma.EloHistoryOrderByWithAggregationInput[]
  by: Prisma.EloHistoryScalarFieldEnum[] | Prisma.EloHistoryScalarFieldEnum
  having?: Prisma.EloHistoryScalarWhereWithAggregatesInput
  take?: number
  skip?: number
  _count?: EloHistoryCountAggregateInputType | true
  _avg?: EloHistoryAvgAggregateInputType
  _sum?: EloHistorySumAggregateInputType
  _min?: EloHistoryMinAggregateInputType
  _max?: EloHistoryMaxAggregateInputType
}

export type EloHistoryGroupByOutputType = {
  id: string
  userId: string
  rating: number
  change: number
  gameId: string | null
  timestamp: Date
  _count: EloHistoryCountAggregateOutputType | null
  _avg: EloHistoryAvgAggregateOutputType | null
  _sum: EloHistorySumAggregateOutputType | null
  _min: EloHistoryMinAggregateOutputType | null
  _max: EloHistoryMaxAggregateOutputType | null
}

type GetEloHistoryGroupByPayload<T extends EloHistoryGroupByArgs> = Prisma.PrismaPromise<
  Array<
    Prisma.PickEnumerable<EloHistoryGroupByOutputType, T['by']> &
      {
        [P in ((keyof T) & (keyof EloHistoryGroupByOutputType))]: P extends '_count'
          ? T[P] extends boolean
            ? number
            : Prisma.GetScalarType<T[P], EloHistoryGroupByOutputType[P]>
          : Prisma.GetScalarType<T[P], EloHistoryGroupByOutputType[P]>
      }
    >
  >



export type EloHistoryWhereInput = {
  AND?: Prisma.EloHistoryWhereInput | Prisma.EloHistoryWhereInput[]
  OR?: Prisma.EloHistoryWhereInput[]
  NOT?: Prisma.EloHistoryWhereInput | Prisma.EloHistoryWhereInput[]
  id?: Prisma.StringFilter<"EloHistory"> | string
  userId?: Prisma.StringFilter<"EloHistory"> | string
  rating?: Prisma.IntFilter<"EloHistory"> | number
  change?: Prisma.IntFilter<"EloHistory"> | number
  gameId?: Prisma.StringNullableFilter<"EloHistory"> | string | null
  timestamp?: Prisma.DateTimeFilter<"EloHistory"> | Date | string
}

export type EloHistoryOrderByWithRelationInput = {
  id?: Prisma.SortOrder
  userId?: Prisma.SortOrder
  rating?: Prisma.SortOrder
  change?: Prisma.SortOrder
  gameId?: Prisma.SortOrderInput | Prisma.SortOrder
  timestamp?: Prisma.SortOrder
}

export type EloHistoryWhereUniqueInput = Prisma.AtLeast<{
  id?: string
  AND?: Prisma.EloHistoryWhereInput | Prisma.EloHistoryWhereInput[]
  OR?: Prisma.EloHistoryWhereInput[]
  NOT?: Prisma.EloHistoryWhereInput | Prisma.EloHistoryWhereInput[]
  userId?: Prisma.StringFilter<"EloHistory"> | string
  rating?: Prisma.IntFilter<"EloHistory"> | number
  change?: Prisma.IntFilter<"EloHistory"> | number
  gameId?: Prisma.StringNullableFilter<"EloHistory"> | string | null
  timestamp?: Prisma.DateTimeFilter<"EloHistory"> | Date | string
}, "id">

export type EloHistoryOrderByWithAggregationInput = {
  id?: Prisma.SortOrder
  userId?: Prisma.SortOrder
  rating?: Prisma.SortOrder
  change?: Prisma.SortOrder
  gameId?: Prisma.SortOrderInput | Prisma.SortOrder
  timestamp?: Prisma.SortOrder
  _count?: Prisma.EloHistoryCountOrderByAggregateInput
  _avg?: Prisma.EloHistoryAvgOrderByAggregateInput
  _max?: Prisma.EloHistoryMaxOrderByAggregateInput
  _min?: Prisma.EloHistoryMinOrderByAggregateInput
  _sum?: Prisma.EloHistorySumOrderByAggregateInput
}

export type EloHistoryScalarWhereWithAggregatesInput = {
  AND?: Prisma.EloHistoryScalarWhereWithAggregatesInput | Prisma.EloHistoryScalarWhereWithAggregatesInput[]
  OR?: Prisma.EloHistoryScalarWhereWithAggregatesInput[]
  NOT?: Prisma.EloHistoryScalarWhereWithAggregatesInput | Prisma.EloHistoryScalarWhereWithAggregatesInput[]
  id?: Prisma.StringWithAggregatesFilter<"EloHistory"> | string
  userId?: Prisma.StringWithAggregatesFilter<"EloHistory"> | string
  rating?: Prisma.IntWithAggregatesFilter<"EloHistory"> | number
  change?: Prisma.IntWithAggregatesFilter<"EloHistory"> | number
  gameId?: Prisma.StringNullableWithAggregatesFilter<"EloHistory"> | string | null
  timestamp?: Prisma.DateTimeWithAggregatesFilter<"EloHistory"> | Date | string
}

export type EloHistoryCreateInput = {
  id?: string
  userId: string
  rating: number
  change: number
  gameId?: string | null
  timestamp?: Date | string
}

export type EloHistoryUncheckedCreateInput = {
  id?: string
  userId: string
  rating: number
  change: number
  gameId?: string | null
  timestamp?: Date | string
}

export type EloHistoryUpdateInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  userId?: Prisma.StringFieldUpdateOperationsInput | string
  rating?: Prisma.IntFieldUpdateOperationsInput | number
  change?: Prisma.IntFieldUpdateOperationsInput | number
  gameId?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  timestamp?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
}

export type EloHistoryUncheckedUpdateInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  userId?: Prisma.StringFieldUpdateOperationsInput | string
  rating?: Prisma.IntFieldUpdateOperationsInput | number
  change?: Prisma.IntFieldUpdateOperationsInput | number
  gameId?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  timestamp?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
}

export type EloHistoryCreateManyInput = {
  id?: string
  userId: string
  rating: number
  change: number
  gameId?: string | null
  timestamp?: Date | string
}

export type EloHistoryUpdateManyMutationInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  userId?: Prisma.StringFieldUpdateOperationsInput | string
  rating?: Prisma.IntFieldUpdateOperationsInput | number
  change?: Prisma.IntFieldUpdateOperationsInput | number
  gameId?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  timestamp?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
}

export type EloHistoryUncheckedUpdateManyInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  userId?: Prisma.StringFieldUpdateOperationsInput | string
  rating?: Prisma.IntFieldUpdateOperationsInput | number
  change?: Prisma.IntFieldUpdateOperationsInput | number
  gameId?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  timestamp?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
}

export type EloHistoryCountOrderByAggregateInput = {
  id?: Prisma.SortOrder
  userId?: Prisma.SortOrder
  rating?: Prisma.SortOrder
  change?: Prisma.SortOrder
  gameId?: Prisma.SortOrder
  timestamp?: Prisma.SortOrder
}

export type EloHistoryAvgOrderByAggregateInput = {
  rating?: Prisma.SortOrder
  change?: Prisma.SortOrder
}

export type EloHistoryMaxOrderByAggregateInput = {
  id?: Prisma.SortOrder
  userId?: Prisma.SortOrder
  rating?: Prisma.SortOrder
  change?: Prisma.SortOrder
  gameId?: Prisma.SortOrder
  timestamp?: Prisma.SortOrder
}

export type EloHistoryMinOrderByAggregateInput = {
  id?: Prisma.SortOrder
  userId?: Prisma.SortOrder
  rating?: Prisma.SortOrder
  change?: Prisma.SortOrder
  gameId?: Prisma.SortOrder
  timestamp?: Prisma.SortOrder
}

export type EloHistorySumOrderByAggregateInput = {
  rating?: Prisma.SortOrder
  change?: Prisma.SortOrder
}



export type EloHistorySelect<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetSelect<{
  id?: boolean
  userId?: boolean
  rating?: boolean
  change?: boolean
  gameId?: boolean
  timestamp?: boolean
}, ExtArgs["result"]["eloHistory"]>

export type EloHistorySelectCreateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetSelect<{
  id?: boolean
  userId?: boolean
  rating?: boolean
  change?: boolean
  gameId?: boolean
  timestamp?: boolean
}, ExtArgs["result"]["eloHistory"]>

export type EloHistorySelectUpdateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetSelect<{
  id?: boolean
  userId?: boolean
  rating?: boolean
  change?: boolean
  gameId?: boolean
  timestamp?: boolean
}, ExtArgs["result"]["eloHistory"]>

export type EloHistorySelectScalar = {
  id?: boolean
  userId?: boolean
  rating?: boolean
  change?: boolean
  gameId?: boolean
  timestamp?: boolean
}

export type EloHistoryOmit<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetOmit<"id" | "userId" | "rating" | "change" | "gameId" | "timestamp", ExtArgs["result"]["eloHistory"]>

export type $EloHistoryPayload<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  name: "EloHistory"
  objects: {}
  scalars: runtime.Types.Extensions.GetPayloadResult<{
    id: string
    userId: string
    rating: number
    change: number
    gameId: string | null
    timestamp: Date
  }, ExtArgs["result"]["eloHistory"]>
  composites: {}
}

export type EloHistoryGetPayload<S extends boolean | null | undefined | EloHistoryDefaultArgs> = runtime.Types.Result.GetResult<Prisma.$EloHistoryPayload, S>

export type EloHistoryCountArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> =
  Omit<EloHistoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
    select?: EloHistoryCountAggregateInputType | true
  }

export interface EloHistoryDelegate<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs, GlobalOmitOptions = {}> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EloHistory'], meta: { name: 'EloHistory' } }
  /**
   * Find zero or one EloHistory that matches the filter.
   * @param {EloHistoryFindUniqueArgs} args - Arguments to find a EloHistory
   * @example
   * // Get one EloHistory
   * const eloHistory = await prisma.eloHistory.findUnique({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findUnique<T extends EloHistoryFindUniqueArgs>(args: Prisma.SelectSubset<T, EloHistoryFindUniqueArgs<ExtArgs>>): Prisma.Prisma__EloHistoryClient<runtime.Types.Result.GetResult<Prisma.$EloHistoryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

  /**
   * Find one EloHistory that matches the filter or throw an error with `error.code='P2025'`
   * if no matches were found.
   * @param {EloHistoryFindUniqueOrThrowArgs} args - Arguments to find a EloHistory
   * @example
   * // Get one EloHistory
   * const eloHistory = await prisma.eloHistory.findUniqueOrThrow({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findUniqueOrThrow<T extends EloHistoryFindUniqueOrThrowArgs>(args: Prisma.SelectSubset<T, EloHistoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma.Prisma__EloHistoryClient<runtime.Types.Result.GetResult<Prisma.$EloHistoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Find the first EloHistory that matches the filter.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {EloHistoryFindFirstArgs} args - Arguments to find a EloHistory
   * @example
   * // Get one EloHistory
   * const eloHistory = await prisma.eloHistory.findFirst({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findFirst<T extends EloHistoryFindFirstArgs>(args?: Prisma.SelectSubset<T, EloHistoryFindFirstArgs<ExtArgs>>): Prisma.Prisma__EloHistoryClient<runtime.Types.Result.GetResult<Prisma.$EloHistoryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

  /**
   * Find the first EloHistory that matches the filter or
   * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {EloHistoryFindFirstOrThrowArgs} args - Arguments to find a EloHistory
   * @example
   * // Get one EloHistory
   * const eloHistory = await prisma.eloHistory.findFirstOrThrow({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findFirstOrThrow<T extends EloHistoryFindFirstOrThrowArgs>(args?: Prisma.SelectSubset<T, EloHistoryFindFirstOrThrowArgs<ExtArgs>>): Prisma.Prisma__EloHistoryClient<runtime.Types.Result.GetResult<Prisma.$EloHistoryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Find zero or more EloHistories that matches the filter.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {EloHistoryFindManyArgs} args - Arguments to filter and select certain fields only.
   * @example
   * // Get all EloHistories
   * const eloHistories = await prisma.eloHistory.findMany()
   * 
   * // Get first 10 EloHistories
   * const eloHistories = await prisma.eloHistory.findMany({ take: 10 })
   * 
   * // Only select the `id`
   * const eloHistoryWithIdOnly = await prisma.eloHistory.findMany({ select: { id: true } })
   * 
   */
  findMany<T extends EloHistoryFindManyArgs>(args?: Prisma.SelectSubset<T, EloHistoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<runtime.Types.Result.GetResult<Prisma.$EloHistoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

  /**
   * Create a EloHistory.
   * @param {EloHistoryCreateArgs} args - Arguments to create a EloHistory.
   * @example
   * // Create one EloHistory
   * const EloHistory = await prisma.eloHistory.create({
   *   data: {
   *     // ... data to create a EloHistory
   *   }
   * })
   * 
   */
  create<T extends EloHistoryCreateArgs>(args: Prisma.SelectSubset<T, EloHistoryCreateArgs<ExtArgs>>): Prisma.Prisma__EloHistoryClient<runtime.Types.Result.GetResult<Prisma.$EloHistoryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Create many EloHistories.
   * @param {EloHistoryCreateManyArgs} args - Arguments to create many EloHistories.
   * @example
   * // Create many EloHistories
   * const eloHistory = await prisma.eloHistory.createMany({
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   *     
   */
  createMany<T extends EloHistoryCreateManyArgs>(args?: Prisma.SelectSubset<T, EloHistoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<Prisma.BatchPayload>

  /**
   * Create many EloHistories and returns the data saved in the database.
   * @param {EloHistoryCreateManyAndReturnArgs} args - Arguments to create many EloHistories.
   * @example
   * // Create many EloHistories
   * const eloHistory = await prisma.eloHistory.createManyAndReturn({
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   * 
   * // Create many EloHistories and only return the `id`
   * const eloHistoryWithIdOnly = await prisma.eloHistory.createManyAndReturn({
   *   select: { id: true },
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * 
   */
  createManyAndReturn<T extends EloHistoryCreateManyAndReturnArgs>(args?: Prisma.SelectSubset<T, EloHistoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<runtime.Types.Result.GetResult<Prisma.$EloHistoryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

  /**
   * Delete a EloHistory.
   * @param {EloHistoryDeleteArgs} args - Arguments to delete one EloHistory.
   * @example
   * // Delete one EloHistory
   * const EloHistory = await prisma.eloHistory.delete({
   *   where: {
   *     // ... filter to delete one EloHistory
   *   }
   * })
   * 
   */
  delete<T extends EloHistoryDeleteArgs>(args: Prisma.SelectSubset<T, EloHistoryDeleteArgs<ExtArgs>>): Prisma.Prisma__EloHistoryClient<runtime.Types.Result.GetResult<Prisma.$EloHistoryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Update one EloHistory.
   * @param {EloHistoryUpdateArgs} args - Arguments to update one EloHistory.
   * @example
   * // Update one EloHistory
   * const eloHistory = await prisma.eloHistory.update({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
   */
  update<T extends EloHistoryUpdateArgs>(args: Prisma.SelectSubset<T, EloHistoryUpdateArgs<ExtArgs>>): Prisma.Prisma__EloHistoryClient<runtime.Types.Result.GetResult<Prisma.$EloHistoryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Delete zero or more EloHistories.
   * @param {EloHistoryDeleteManyArgs} args - Arguments to filter EloHistories to delete.
   * @example
   * // Delete a few EloHistories
   * const { count } = await prisma.eloHistory.deleteMany({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   * 
   */
  deleteMany<T extends EloHistoryDeleteManyArgs>(args?: Prisma.SelectSubset<T, EloHistoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<Prisma.BatchPayload>

  /**
   * Update zero or more EloHistories.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {EloHistoryUpdateManyArgs} args - Arguments to update one or more rows.
   * @example
   * // Update many EloHistories
   * const eloHistory = await prisma.eloHistory.updateMany({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
   */
  updateMany<T extends EloHistoryUpdateManyArgs>(args: Prisma.SelectSubset<T, EloHistoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<Prisma.BatchPayload>

  /**
   * Update zero or more EloHistories and returns the data updated in the database.
   * @param {EloHistoryUpdateManyAndReturnArgs} args - Arguments to update many EloHistories.
   * @example
   * // Update many EloHistories
   * const eloHistory = await prisma.eloHistory.updateManyAndReturn({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   * 
   * // Update zero or more EloHistories and only return the `id`
   * const eloHistoryWithIdOnly = await prisma.eloHistory.updateManyAndReturn({
   *   select: { id: true },
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * 
   */
  updateManyAndReturn<T extends EloHistoryUpdateManyAndReturnArgs>(args: Prisma.SelectSubset<T, EloHistoryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<runtime.Types.Result.GetResult<Prisma.$EloHistoryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

  /**
   * Create or update one EloHistory.
   * @param {EloHistoryUpsertArgs} args - Arguments to update or create a EloHistory.
   * @example
   * // Update or create a EloHistory
   * const eloHistory = await prisma.eloHistory.upsert({
   *   create: {
   *     // ... data to create a EloHistory
   *   },
   *   update: {
   *     // ... in case it already exists, update
   *   },
   *   where: {
   *     // ... the filter for the EloHistory we want to update
   *   }
   * })
   */
  upsert<T extends EloHistoryUpsertArgs>(args: Prisma.SelectSubset<T, EloHistoryUpsertArgs<ExtArgs>>): Prisma.Prisma__EloHistoryClient<runtime.Types.Result.GetResult<Prisma.$EloHistoryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


  /**
   * Count the number of EloHistories.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {EloHistoryCountArgs} args - Arguments to filter EloHistories to count.
   * @example
   * // Count the number of EloHistories
   * const count = await prisma.eloHistory.count({
   *   where: {
   *     // ... the filter for the EloHistories we want to count
   *   }
   * })
  **/
  count<T extends EloHistoryCountArgs>(
    args?: Prisma.Subset<T, EloHistoryCountArgs>,
  ): Prisma.PrismaPromise<
    T extends runtime.Types.Utils.Record<'select', any>
      ? T['select'] extends true
        ? number
        : Prisma.GetScalarType<T['select'], EloHistoryCountAggregateOutputType>
      : number
  >

  /**
   * Allows you to perform aggregations operations on a EloHistory.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {EloHistoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
   * @example
   * // Ordered by age ascending
   * // Where email contains prisma.io
   * // Limited to the 10 users
   * const aggregations = await prisma.user.aggregate({
   *   _avg: {
   *     age: true,
   *   },
   *   where: {
   *     email: {
   *       contains: "prisma.io",
   *     },
   *   },
   *   orderBy: {
   *     age: "asc",
   *   },
   *   take: 10,
   * })
  **/
  aggregate<T extends EloHistoryAggregateArgs>(args: Prisma.Subset<T, EloHistoryAggregateArgs>): Prisma.PrismaPromise<GetEloHistoryAggregateType<T>>

  /**
   * Group by EloHistory.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {EloHistoryGroupByArgs} args - Group by arguments.
   * @example
   * // Group by city, order by createdAt, get count
   * const result = await prisma.user.groupBy({
   *   by: ['city', 'createdAt'],
   *   orderBy: {
   *     createdAt: true
   *   },
   *   _count: {
   *     _all: true
   *   },
   * })
   * 
  **/
  groupBy<
    T extends EloHistoryGroupByArgs,
    HasSelectOrTake extends Prisma.Or<
      Prisma.Extends<'skip', Prisma.Keys<T>>,
      Prisma.Extends<'take', Prisma.Keys<T>>
    >,
    OrderByArg extends Prisma.True extends HasSelectOrTake
      ? { orderBy: EloHistoryGroupByArgs['orderBy'] }
      : { orderBy?: EloHistoryGroupByArgs['orderBy'] },
    OrderFields extends Prisma.ExcludeUnderscoreKeys<Prisma.Keys<Prisma.MaybeTupleToUnion<T['orderBy']>>>,
    ByFields extends Prisma.MaybeTupleToUnion<T['by']>,
    ByValid extends Prisma.Has<ByFields, OrderFields>,
    HavingFields extends Prisma.GetHavingFields<T['having']>,
    HavingValid extends Prisma.Has<ByFields, HavingFields>,
    ByEmpty extends T['by'] extends never[] ? Prisma.True : Prisma.False,
    InputErrors extends ByEmpty extends Prisma.True
    ? `Error: "by" must not be empty.`
    : HavingValid extends Prisma.False
    ? {
        [P in HavingFields]: P extends ByFields
          ? never
          : P extends string
          ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
          : [
              Error,
              'Field ',
              P,
              ` in "having" needs to be provided in "by"`,
            ]
      }[HavingFields]
    : 'take' extends Prisma.Keys<T>
    ? 'orderBy' extends Prisma.Keys<T>
      ? ByValid extends Prisma.True
        ? {}
        : {
            [P in OrderFields]: P extends ByFields
              ? never
              : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
          }[OrderFields]
      : 'Error: If you provide "take", you also need to provide "orderBy"'
    : 'skip' extends Prisma.Keys<T>
    ? 'orderBy' extends Prisma.Keys<T>
      ? ByValid extends Prisma.True
        ? {}
        : {
            [P in OrderFields]: P extends ByFields
              ? never
              : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
          }[OrderFields]
      : 'Error: If you provide "skip", you also need to provide "orderBy"'
    : ByValid extends Prisma.True
    ? {}
    : {
        [P in OrderFields]: P extends ByFields
          ? never
          : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
      }[OrderFields]
  >(args: Prisma.SubsetIntersection<T, EloHistoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEloHistoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
/**
 * Fields of the EloHistory model
 */
readonly fields: EloHistoryFieldRefs;
}

/**
 * The delegate class that acts as a "Promise-like" for EloHistory.
 * Why is this prefixed with `Prisma__`?
 * Because we want to prevent naming conflicts as mentioned in
 * https://github.com/prisma/prisma-client-js/issues/707
 */
export interface Prisma__EloHistoryClient<T, Null = never, ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
  readonly [Symbol.toStringTag]: "PrismaPromise"
  /**
   * Attaches callbacks for the resolution and/or rejection of the Promise.
   * @param onfulfilled The callback to execute when the Promise is resolved.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of which ever callback is executed.
   */
  then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): runtime.Types.Utils.JsPromise<TResult1 | TResult2>
  /**
   * Attaches a callback for only the rejection of the Promise.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of the callback.
   */
  catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): runtime.Types.Utils.JsPromise<T | TResult>
  /**
   * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
   * resolved value cannot be modified from the callback.
   * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
   * @returns A Promise for the completion of the callback.
   */
  finally(onfinally?: (() => void) | undefined | null): runtime.Types.Utils.JsPromise<T>
}




/**
 * Fields of the EloHistory model
 */
export interface EloHistoryFieldRefs {
  readonly id: Prisma.FieldRef<"EloHistory", 'String'>
  readonly userId: Prisma.FieldRef<"EloHistory", 'String'>
  readonly rating: Prisma.FieldRef<"EloHistory", 'Int'>
  readonly change: Prisma.FieldRef<"EloHistory", 'Int'>
  readonly gameId: Prisma.FieldRef<"EloHistory", 'String'>
  readonly timestamp: Prisma.FieldRef<"EloHistory", 'DateTime'>
}
    

// Custom InputTypes
/**
 * EloHistory findUnique
 */
export type EloHistoryFindUniqueArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the EloHistory
   */
  select?: Prisma.EloHistorySelect<ExtArgs> | null
  /**
   * Omit specific fields from the EloHistory
   */
  omit?: Prisma.EloHistoryOmit<ExtArgs> | null
  /**
   * Filter, which EloHistory to fetch.
   */
  where: Prisma.EloHistoryWhereUniqueInput
}

/**
 * EloHistory findUniqueOrThrow
 */
export type EloHistoryFindUniqueOrThrowArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the EloHistory
   */
  select?: Prisma.EloHistorySelect<ExtArgs> | null
  /**
   * Omit specific fields from the EloHistory
   */
  omit?: Prisma.EloHistoryOmit<ExtArgs> | null
  /**
   * Filter, which EloHistory to fetch.
   */
  where: Prisma.EloHistoryWhereUniqueInput
}

/**
 * EloHistory findFirst
 */
export type EloHistoryFindFirstArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the EloHistory
   */
  select?: Prisma.EloHistorySelect<ExtArgs> | null
  /**
   * Omit specific fields from the EloHistory
   */
  omit?: Prisma.EloHistoryOmit<ExtArgs> | null
  /**
   * Filter, which EloHistory to fetch.
   */
  where?: Prisma.EloHistoryWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of EloHistories to fetch.
   */
  orderBy?: Prisma.EloHistoryOrderByWithRelationInput | Prisma.EloHistoryOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the position for searching for EloHistories.
   */
  cursor?: Prisma.EloHistoryWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `Â±n` EloHistories from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` EloHistories.
   */
  skip?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
   * 
   * Filter by unique combinations of EloHistories.
   */
  distinct?: Prisma.EloHistoryScalarFieldEnum | Prisma.EloHistoryScalarFieldEnum[]
}

/**
 * EloHistory findFirstOrThrow
 */
export type EloHistoryFindFirstOrThrowArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the EloHistory
   */
  select?: Prisma.EloHistorySelect<ExtArgs> | null
  /**
   * Omit specific fields from the EloHistory
   */
  omit?: Prisma.EloHistoryOmit<ExtArgs> | null
  /**
   * Filter, which EloHistory to fetch.
   */
  where?: Prisma.EloHistoryWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of EloHistories to fetch.
   */
  orderBy?: Prisma.EloHistoryOrderByWithRelationInput | Prisma.EloHistoryOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the position for searching for EloHistories.
   */
  cursor?: Prisma.EloHistoryWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `Â±n` EloHistories from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` EloHistories.
   */
  skip?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
   * 
   * Filter by unique combinations of EloHistories.
   */
  distinct?: Prisma.EloHistoryScalarFieldEnum | Prisma.EloHistoryScalarFieldEnum[]
}

/**
 * EloHistory findMany
 */
export type EloHistoryFindManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the EloHistory
   */
  select?: Prisma.EloHistorySelect<ExtArgs> | null
  /**
   * Omit specific fields from the EloHistory
   */
  omit?: Prisma.EloHistoryOmit<ExtArgs> | null
  /**
   * Filter, which EloHistories to fetch.
   */
  where?: Prisma.EloHistoryWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of EloHistories to fetch.
   */
  orderBy?: Prisma.EloHistoryOrderByWithRelationInput | Prisma.EloHistoryOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the position for listing EloHistories.
   */
  cursor?: Prisma.EloHistoryWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `Â±n` EloHistories from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` EloHistories.
   */
  skip?: number
  distinct?: Prisma.EloHistoryScalarFieldEnum | Prisma.EloHistoryScalarFieldEnum[]
}

/**
 * EloHistory create
 */
export type EloHistoryCreateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the EloHistory
   */
  select?: Prisma.EloHistorySelect<ExtArgs> | null
  /**
   * Omit specific fields from the EloHistory
   */
  omit?: Prisma.EloHistoryOmit<ExtArgs> | null
  /**
   * The data needed to create a EloHistory.
   */
  data: Prisma.XOR<Prisma.EloHistoryCreateInput, Prisma.EloHistoryUncheckedCreateInput>
}

/**
 * EloHistory createMany
 */
export type EloHistoryCreateManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * The data used to create many EloHistories.
   */
  data: Prisma.EloHistoryCreateManyInput | Prisma.EloHistoryCreateManyInput[]
  skipDuplicates?: boolean
}

/**
 * EloHistory createManyAndReturn
 */
export type EloHistoryCreateManyAndReturnArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the EloHistory
   */
  select?: Prisma.EloHistorySelectCreateManyAndReturn<ExtArgs> | null
  /**
   * Omit specific fields from the EloHistory
   */
  omit?: Prisma.EloHistoryOmit<ExtArgs> | null
  /**
   * The data used to create many EloHistories.
   */
  data: Prisma.EloHistoryCreateManyInput | Prisma.EloHistoryCreateManyInput[]
  skipDuplicates?: boolean
}

/**
 * EloHistory update
 */
export type EloHistoryUpdateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the EloHistory
   */
  select?: Prisma.EloHistorySelect<ExtArgs> | null
  /**
   * Omit specific fields from the EloHistory
   */
  omit?: Prisma.EloHistoryOmit<ExtArgs> | null
  /**
   * The data needed to update a EloHistory.
   */
  data: Prisma.XOR<Prisma.EloHistoryUpdateInput, Prisma.EloHistoryUncheckedUpdateInput>
  /**
   * Choose, which EloHistory to update.
   */
  where: Prisma.EloHistoryWhereUniqueInput
}

/**
 * EloHistory updateMany
 */
export type EloHistoryUpdateManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * The data used to update EloHistories.
   */
  data: Prisma.XOR<Prisma.EloHistoryUpdateManyMutationInput, Prisma.EloHistoryUncheckedUpdateManyInput>
  /**
   * Filter which EloHistories to update
   */
  where?: Prisma.EloHistoryWhereInput
  /**
   * Limit how many EloHistories to update.
   */
  limit?: number
}

/**
 * EloHistory updateManyAndReturn
 */
export type EloHistoryUpdateManyAndReturnArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the EloHistory
   */
  select?: Prisma.EloHistorySelectUpdateManyAndReturn<ExtArgs> | null
  /**
   * Omit specific fields from the EloHistory
   */
  omit?: Prisma.EloHistoryOmit<ExtArgs> | null
  /**
   * The data used to update EloHistories.
   */
  data: Prisma.XOR<Prisma.EloHistoryUpdateManyMutationInput, Prisma.EloHistoryUncheckedUpdateManyInput>
  /**
   * Filter which EloHistories to update
   */
  where?: Prisma.EloHistoryWhereInput
  /**
   * Limit how many EloHistories to update.
   */
  limit?: number
}

/**
 * EloHistory upsert
 */
export type EloHistoryUpsertArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the EloHistory
   */
  select?: Prisma.EloHistorySelect<ExtArgs> | null
  /**
   * Omit specific fields from the EloHistory
   */
  omit?: Prisma.EloHistoryOmit<ExtArgs> | null
  /**
   * The filter to search for the EloHistory to update in case it exists.
   */
  where: Prisma.EloHistoryWhereUniqueInput
  /**
   * In case the EloHistory found by the `where` argument doesn't exist, create a new EloHistory with this data.
   */
  create: Prisma.XOR<Prisma.EloHistoryCreateInput, Prisma.EloHistoryUncheckedCreateInput>
  /**
   * In case the EloHistory was found with the provided `where` argument, update it with this data.
   */
  update: Prisma.XOR<Prisma.EloHistoryUpdateInput, Prisma.EloHistoryUncheckedUpdateInput>
}

/**
 * EloHistory delete
 */
export type EloHistoryDeleteArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the EloHistory
   */
  select?: Prisma.EloHistorySelect<ExtArgs> | null
  /**
   * Omit specific fields from the EloHistory
   */
  omit?: Prisma.EloHistoryOmit<ExtArgs> | null
  /**
   * Filter which EloHistory to delete.
   */
  where: Prisma.EloHistoryWhereUniqueInput
}

/**
 * EloHistory deleteMany
 */
export type EloHistoryDeleteManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Filter which EloHistories to delete
   */
  where?: Prisma.EloHistoryWhereInput
  /**
   * Limit how many EloHistories to delete.
   */
  limit?: number
}

/**
 * EloHistory without action
 */
export type EloHistoryDefaultArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the EloHistory
   */
  select?: Prisma.EloHistorySelect<ExtArgs> | null
  /**
   * Omit specific fields from the EloHistory
   */
  omit?: Prisma.EloHistoryOmit<ExtArgs> | null
}
